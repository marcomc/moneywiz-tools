#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import sqlite3
from dataclasses import dataclass, asdict
from pathlib import Path
from typing import Any, Dict, List


@dataclass
class Column:
    cid: int
    name: str
    type: str
    notnull: int
    dflt_value: Any
    pk: int


@dataclass
class ForeignKey:
    id: int
    seq: int
    table: str
    from_col: str
    to_col: str
    on_update: str
    on_delete: str
    match: str


@dataclass
class IndexCol:
    seqno: int
    cid: int
    name: str


@dataclass
class Index:
    name: str
    unique: int
    origin: str
    partial: int
    cols: List[IndexCol]


@dataclass
class Table:
    name: str
    sql: str | None
    columns: List[Column]
    foreign_keys: List[ForeignKey]
    indexes: List[Index]
    row_count: int | None


def fetch_tables(con: sqlite3.Connection) -> List[Table]:
    cur = con.cursor()
    tbl_rows = cur.execute(
        "SELECT name, sql FROM sqlite_master WHERE type='table' ORDER BY name"
    ).fetchall()

    tables: List[Table] = []

    for name, sql in tbl_rows:
        # columns
        cols: List[Column] = []
        for c in cur.execute(f"PRAGMA table_info('{name}')").fetchall():
            cols.append(
                Column(
                    cid=c[0], name=c[1], type=c[2] or "",
                    notnull=c[3], dflt_value=c[4], pk=c[5]
                )
            )

        # foreign keys
        fks: List[ForeignKey] = []
        try:
            fk_rows = cur.execute(f"PRAGMA foreign_key_list('{name}')").fetchall()
        except sqlite3.DatabaseError:
            fk_rows = []
        for fk in fk_rows:
            fks.append(
                ForeignKey(
                    id=fk[0], seq=fk[1], table=fk[2], from_col=fk[3], to_col=fk[4],
                    on_update=fk[5], on_delete=fk[6], match=fk[7]
                )
            )

        # indexes
        idxs: List[Index] = []
        try:
            idx_rows = cur.execute(f"PRAGMA index_list('{name}')").fetchall()
        except sqlite3.DatabaseError:
            idx_rows = []
        for idx in idx_rows:
            iname, unique, origin, partial = idx[1], idx[2], idx[3], idx[4]
            cols_rows = cur.execute(f"PRAGMA index_info('{iname}')").fetchall()
            cols_info = [IndexCol(seqno=r[0], cid=r[1], name=r[2]) for r in cols_rows]
            idxs.append(Index(name=iname, unique=unique, origin=origin, partial=partial, cols=cols_info))

        # count rows (best-effort)
        row_count: int | None = None
        try:
            row_count = cur.execute(f"SELECT COUNT(1) FROM '{name}'").fetchone()[0]
        except sqlite3.DatabaseError:
            row_count = None

        tables.append(Table(name=name, sql=sql, columns=cols, foreign_keys=fks, indexes=idxs, row_count=row_count))

    return tables


def main() -> int:
    ap = argparse.ArgumentParser(description="Introspect SQLite DB and print schema")
    ap.add_argument("--db", type=Path, required=True, help="Path to sqlite DB")
    ap.add_argument("--format", choices=["md", "json"], default="md")
    args = ap.parse_args()

    con = sqlite3.connect(args.db)
    tables = fetch_tables(con)
    con.close()

    if args.format == "json":
        out = [
            {
                "name": t.name,
                "sql": t.sql,
                "row_count": t.row_count,
                "columns": [asdict(c) for c in t.columns],
                "foreign_keys": [asdict(fk) for fk in t.foreign_keys],
                "indexes": [
                    {"name": i.name, "unique": i.unique, "origin": i.origin, "partial": i.partial, "cols": [asdict(ic) for ic in i.cols]}
                    for i in t.indexes
                ],
            }
            for t in tables
        ]
        print(json.dumps(out, indent=2))
        return 0

    # Markdown output
    lines: List[str] = []
    lines.append(f"# Database Schema: {args.db}")
    lines.append("")
    lines.append("This document was generated by scripts/introspect_db.py.")
    lines.append("")
    for t in tables:
        lines.append(f"## Table `{t.name}` ({t.row_count if t.row_count is not None else 'unknown'} rows)")
        lines.append("")
        if t.sql:
            lines.append("```sql")
            lines.append(t.sql)
            lines.append("```")
            lines.append("")
        lines.append("- Columns:")
        for c in t.columns:
            nn = " NOT NULL" if c.notnull else ""
            pk = " PRIMARY KEY" if c.pk else ""
            dv = f" DEFAULT {c.dflt_value}" if c.dflt_value is not None else ""
            lines.append(f"  - {c.name}: {c.type}{nn}{pk}{dv}")
        if t.foreign_keys:
            lines.append("- Foreign Keys:")
            for fk in t.foreign_keys:
                lines.append(
                    f"  - {fk.from_col} -> {fk.table}({fk.to_col}) ON UPDATE {fk.on_update} ON DELETE {fk.on_delete} MATCH {fk.match}"
                )
        if t.indexes:
            lines.append("- Indexes:")
            for i in t.indexes:
                cols = ", ".join(ic.name for ic in i.cols)
                lines.append(f"  - {i.name}: unique={i.unique}, origin={i.origin}, partial={i.partial}; cols: {cols}")
        lines.append("")

    print("\n".join(lines))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())

